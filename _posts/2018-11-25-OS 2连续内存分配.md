---
layout:     post
title:      OS 2连续内存分配        
date:       2018-11-25      
author:     lsq    
header-img: img/post-bg-coffee.jpeg
catalog: true
tags:
    - OS
---


# 1 背景
内存是现代计算机运行的中心，内存由很大一组字或字节组成，每个字或字节都有它们自己的地址，CPU根据程序计数器的值从内存中读取指令，这些指令可能会引起进一步对特定内存地址的读取和写入。一个典型的指令执行周期，首先从内存中读取指令，接着该指令被解码，且可能需要从内存中读取操作数，在指令对操作数执行后，其结果可能被存回到内存。

CPU能直接访问的存储器只有内存和处理器内的寄存器，机器指令可以用内存地址作为参数，而不能用磁盘地址作为参数。因此，执行指令以及指令使用的数据必须在这些直接可访问的存储设备上。如果数据不在内存中，那么在使用CPU前必须先把数据移到内存中。

CPU内置寄存器通常可以在一个CPU时钟周期内访问完成，完成对内存的访问可能需要多个CPU时钟周期，而且通常会出现等待的情况。由于内存访问频繁，这种情况难以忍受，解决方法是在CPU与内存之间增加高速内存，成为高速缓存（cache）。

为了确保操作系统不被用户进程所访问，以及确保用户进程不被其他用户进程访问，需要确保每个进程都有独立的内存空间。这种保护通过两个寄存器实现，即基地址寄存器和界限地址寄存器。基地址寄存器含有最小的合法物理内存地址，而界限地址寄存器决定了范围的大小。


通常程序以二进制可执行文件的形式存储在磁盘上，为了执行，程序被调入内存并放在进程空间内。根据所使用的内存管理方案，进程在执行时可以在磁盘和内存之间移动，在磁盘上等待调入内存以便执行的进程新城输入队列。许多系统允许用户进程放在物理内存的任意位置，源程序中的地址的通常是用符号来表示的，编译器通常将这些符号地址绑定在可重定位的地址，链接程序或加载程序再将这些可重定位的地址绑定成绝对地址，每次绑定都是从一个地址空间到另一个地址空间的映射。

通常，将指令与数据绑定到内存地址有以下一种情况：`编译时`可以生成绝对代码；`加载时`必须生成可重定位代码；`执行时`是绝大多数通用计算机操作系统采用的方法。

CPU所生成的地址通常称为`逻辑地址`（logical address），而内存单元所看到的地址通常称为`物理地址`。将逻辑地址映射成物理地址的是`内存管理单元`(memory management unit),逻辑地址的意义在于让每个用户进程都拥有独立的地址空间。编译和加载时的地址绑定方法生成相同的逻辑地址和物理地址，执行时的地址绑定方案导致不同的逻辑地址和物理地址。基地址寄存器在这里成为重定位寄存器，用户进程所生成的地址在送交内存之前，都将加上重定位寄存器的值，如下图所示。

![](https://github.com/liferlisiqi/liferlisiqi.github.io/blob/master/img/2018-11-25_211944.jpg)


# 2 交换















## Reference
操作系统概念  
[操作系统-清华大学](http://os.cs.tsinghua.edu.cn/oscourse/OS2017spring)
[Operation system: three easy piece](http://pages.cs.wisc.edu/~remzi/OSTEP/)
