---
layout:     post
title:      OS 2物理内存管理        
date:       2018-11-25      
author:     lsq    
header-img: img/post-bg-coffee.jpeg
catalog: true
tags:
    - OS
---


# 1 背景
内存是现代计算机运行的中心，内存由很大一组字或字节组成，每个字或字节都有它们自己的地址，CPU根据程序计数器的值从内存中读取指令，这些指令可能会引起进一步对特定内存地址的读取和写入。一个典型的指令执行周期，首先从内存中读取指令，接着该指令被解码，且可能需要从内存中读取操作数，在指令对操作数执行后，其结果可能被存回到内存。

CPU能直接访问的存储器只有内存和处理器内的寄存器，机器指令可以用内存地址作为参数，而不能用磁盘地址作为参数。因此，执行指令以及指令使用的数据必须在这些直接可访问的存储设备上。如果数据不在内存中，那么在使用CPU前必须先把数据移到内存中。

CPU内置寄存器通常可以在一个CPU时钟周期内访问完成，完成对内存的访问可能需要多个CPU时钟周期，而且通常会出现等待的情况。由于内存访问频繁，这种情况难以忍受，解决方法是在CPU与内存之间增加高速内存，成为高速缓存（cache）。

为了确保操作系统不被用户进程所访问，以及确保用户进程不被其他用户进程访问，需要确保每个进程都有独立的内存空间。这种保护通过两个寄存器实现，即基地址寄存器和界限地址寄存器。基地址寄存器含有最小的合法物理内存地址，而界限地址寄存器决定了范围的大小。


通常程序以二进制可执行文件的形式存储在磁盘上，为了执行，程序被调入内存并放在进程空间内。根据所使用的内存管理方案，进程在执行时可以在磁盘和内存之间移动，在磁盘上等待调入内存以便执行的进程新城输入队列。许多系统允许用户进程放在物理内存的任意位置，源程序中的地址的通常是用符号来表示的，编译器通常将这些符号地址绑定在可重定位的地址，链接程序或加载程序再将这些可重定位的地址绑定成绝对地址，每次绑定都是从一个地址空间到另一个地址空间的映射。

通常，将指令与数据绑定到内存地址有以下一种情况：`编译时`可以生成绝对代码；`加载时`必须生成可重定位代码；`执行时`是绝大多数通用计算机操作系统采用的方法。

CPU所生成的地址通常称为`逻辑地址`（logical address），而内存单元所看到的地址通常称为`物理地址`。将逻辑地址映射成物理地址的是`内存管理单元`(memory management unit),逻辑地址的意义在于让每个用户进程都拥有独立的地址空间。编译和加载时的地址绑定方法生成相同的逻辑地址和物理地址，执行时的地址绑定方案导致不同的逻辑地址和物理地址。基地址寄存器在这里成为重定位寄存器，用户进程所生成的地址在送交内存之前，都将加上重定位寄存器的值，如下图所示。

![](https://raw.githubusercontent.com/liferlisiqi/liferlisiqi.github.io/master/img/2018-11-25_211944.jpg)


# 2 交换
进程需要在内存中以便执行，不过，进程可以暂时从内存中交换到备份存储上，当需要再次执行时再调回到内存中。当每个进程用完时间片，它将与另一进程进行交换，在理想情况下，内存管理器可以足够快的速度交换进程，以便当CPU调度器需要调度CPU时，总有进程在内存中可以执行。除此之外，时间片必须足够大，以保证交换之间可以进行一定量的计算。

这种交换策略的变种被用在基于优先级的调度算法中，当更高优先级的进程执行完后，低优先级进程可以交换回内存以继续执行。交换需要备份存储，备份存储通常是快速磁盘。系统有一个就绪队列，它包括在备份存储或在内存中准备运行的所有进程。交换系统的上下文切换时间比较长，为了有效使用CPU，需要使每个进程的执行时间比交换时间长，交换时间的主要部分是转移时间。

# 3 连续内存分配
内存通常分为两个区域：一个用于驻留操作系统，另一个用于用户进程。通常需要将多个进程同时放在内存中，因此需要考虑如何为输入队列中需要调入内存的进程分配内存空间。

在分配内存时，需要考虑到内存映射与保护问题，这种保护通过重定位寄存器和界限地址寄存器实现，MMU动态地将将逻辑地址加上重定位寄存器值后映射成物理地址，映射后的物理地址再送给内存单元，如图所示。

![](https://github.com/liferlisiqi/liferlisiqi.github.io/raw/master/img/2018-11-26_os2.jpg)

最为简单的内存分配方法之一就是将内存非为多个固定大小的分区，每个分区只能容纳一个进程。当一个分区空闲时，可以从输入队列中选择一个进程，调入到空闲分区。现在使用更多的是可变分区，在该方案中，操作系统有一个表，用于记录哪些内容可用和哪些内存一杯占用。

在任意时候，有一组可用内存大小列表和输入队列，操作系统根据调度算法来对输入队列进行排序，并不断给进程分配内存。通常，存在一组不同大小的内存，如果内存太大，那么就分为两块：一块分配给进程，另一块返回给内存集合。从一组可用内存中选择一个空闲内存的方法有：首次适应、最佳适应和最差适应。

`首次适应`：分配第一个足够大的内存块  
`最佳适应`：分配最小的足够大的内存块  
`最差适应`：分配最大的内存块  

首次适应和最佳适应方法都有`外部碎片`问题，该问题是指当所有总的内存之和可以满足请求但并不连续。内存碎片可以是外部的，也可以是内部的。通常将内存以固定大小的块为单位来分配，可能导致分配的内存比内存需要的大，多出来内存在分区内，但是并不能使用，成为`内部碎片`。

一种解决外部碎片问题的方法是`紧缩`,思路是移动内存内容，以便所有空闲空间合并成一整块，但这种方法并非总是可能的，而且有可能开销巨大。另一种方法是允许物理地址空间为非连续，只要有物理内存就可为进程分配，这种方案有两种互补的技术：分页和分段。

# 4 分页














## Reference
操作系统概念    
[操作系统-清华大学](http://os.cs.tsinghua.edu.cn/oscourse/OS2017spring)  
[Operation system: three easy piece](http://pages.cs.wisc.edu/~remzi/OSTEP/)  
