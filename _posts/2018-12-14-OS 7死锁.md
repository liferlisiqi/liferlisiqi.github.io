---
layout:     post
title:      OS 7死锁        
date:       2018-12-14   
author:     lsq    
header-img: img/post-bg-coffee.jpeg
catalog: true
tags:
    - OS
---

在多到程序环境下，多个进程可能竞争一定数量的资源。如果某个进程申请的资源不可用，那么该进程进入等待状态。如果所申请的资源被其他等待进程占有，那么该等待进程有可能再也无法改变其状态，称为`死锁`（deadlock）。在正常操作模式下，进程只能按如下顺序使用资源：申请->使用->释放。多个线程可能因为竞争共享资源而容易出现死锁。如果在一个系统中下面4个条件同时满足，那么会引起死锁：

- `互斥`：至少有一个资源必须处于非共享模式。
- `占有并等待`：一个进程必须占有至少一个资源，并等待另一资源，而该资源为其他进程所占有。
- `非抢占`：资源不能被抢占。
- `循环等待`：该条件意味着占有并等待条件。

从原理上来说，有三种方法可以处理死锁问题：
- 可使用协议以`预防`或`避免`死锁，确保系统不会进入死锁状态。
- 可允许系统进入死锁状态，然后`检测`它并`恢复`.
- 忽视死锁问题，认为死锁不可能在系统内发生。

`死锁预防`是一组方法，确保至少一个必要条件不成立，这些方法通过限制如何申请资源的方法来预防死锁。`死锁避免`要求操作系统事先得到有关进程申请资源和使用资源的额外信息。如果系统不使用死锁预防或死锁避免算法，那么可提供一个算法来检查系统状态以确定死锁是否发生，并提供另一个算法来从死锁中恢复。对许多系统，死多很少发生，与使用频繁且开销昂贵的死锁预防、死锁避免和死锁检测与恢复算法相比，可使用人工重启的方式。

## 1 死锁预防
出现死锁有四个必要条件，只要确保至少一个必要条件不成立，就能预防死锁发生，下面讨论通过限制四个必要条件来预防死锁。
- `互斥`：对于非共享资源，必须要有互斥条件，所以通常不能通过否定互斥条件来预防死锁。
- `占有并等待`：为了确保占有并等待条件不会在系统内出现，必须保证当一个进程申请一个资源时，它不能占有其他资源。一种协议是每个进程在执行前申请并获得所有资源；第二种协议是允许进程在没有资源时才可申请资源，也可以理解为边执行边申请。这两种协议共同的缺点时，必须在开始前申请所有资源，这可能导致饥饿。
- `非抢占`：对于非抢占条件，为了确保这一条件不成立，可以使用如下协议：如果一个进程占有资源并申请另一个不能立即分配的资源，那么其现已分配的资源都可被抢占。换句话说，这些资源都被隐式地抢占了。这个协议通常应用于状态可以保存和恢复的资源，如CPU寄存器和内存。
- `循环等待`：一个确保此条件不成立的方法是，给所有的资源进行完全排序，要求必须按照递增顺序进行申请资源，排序的规则应该根据系统内资源使用的正常顺序来定义，否则依然不能避免死锁。

## 2 死锁避免


## 3 死锁的检测和恢复


## Reference
操作系统概念    
[操作系统-清华大学](http://os.cs.tsinghua.edu.cn/oscourse/OS2017spring)  
[Operation system: three easy piece](http://pages.cs.wisc.edu/~remzi/OSTEP/) 
