---
layout:     post
title:      OS 7死锁        
date:       2018-12-14   
author:     lsq    
header-img: img/post-bg-coffee.jpeg
catalog: true
tags:
    - OS
---

在多到程序环境下，多个进程可能竞争一定数量的资源。如果某个进程申请的资源不可用，那么该进程进入等待状态。如果所申请的资源被其他等待进程占有，那么该等待进程有可能再也无法改变其状态，称为`死锁`（deadlock）。在正常操作模式下，进程只能按如下顺序使用资源：申请->使用->释放。多个线程可能因为竞争共享资源而容易出现死锁。如果在一个系统中下面4个条件同时满足，那么会引起死锁：

- `互斥`：至少有一个资源必须处于非共享模式。
- `占有并等待`：一个进程必须占有至少一个资源，并等待另一资源，而该资源为其他进程所占有。
- `非抢占`：资源不能被抢占。
- `循环等待`：该条件意味着占有并等待条件。

从原理上来说，有三种方法可以处理死锁问题：
- 可使用协议以`预防`或`避免`死锁，确保系统不会进入死锁状态。
- 可允许系统进入死锁状态，然后`检测`它并`恢复`.
- 忽视死锁问题，认为死锁不可能在系统内发生。

`死锁预防`是一组方法，确保至少一个必要条件不成立，这些方法通过限制如何申请资源的方法来预防死锁。`死锁避免`要求操作系统事先得到有关进程申请资源和使用资源的额外信息。如果系统不使用死锁预防或死锁避免算法，那么可提供一个算法来检查系统状态以确定死锁是否发生，并提供另一个算法来从死锁中恢复。对许多系统，死多很少发生，与使用频繁且开销昂贵的死锁预防、死锁避免和死锁检测与恢复算法相比，可使用人工重启的方式。



## Reference
操作系统概念    
[操作系统-清华大学](http://os.cs.tsinghua.edu.cn/oscourse/OS2017spring)  
[Operation system: three easy piece](http://pages.cs.wisc.edu/~remzi/OSTEP/) 
