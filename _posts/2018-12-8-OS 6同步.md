---
layout:     post
title:      OS 6同步        
date:       2018-12-8   
author:     lsq    
header-img: img/post-bg-coffee.jpeg
catalog: true
tags:
    - OS
---

协作进程是可以与在系统内执行的其他进程互相影响的进程，他们可以直接共享逻辑地址空间（代码和数据），或者只通过文件或消息来共享数据。多个进程并发访问和操作同一数据且执行结果与访问发生的特定顺序有关，称为竞争条件。为了避免竞争条件，需要确保一段时间内只有一个进程能操作变量。为了实现这种保证，要求进行一定形式的进程同步。

## 1 临界区问题
每个进程有一个代码段称为`临界区`（criticalsection），在该区中进程可能改变共同变量、更新一个表、写一个文件等，当一个进程进入临界区，没有其他进程可被允许在临界区内执行。临界区问题是设计一个以便进程协作的协议，每个进程必须请求允许进入其临界区，实现这一请求的代码段称为`进入区`，临界区之后可有`退出区`，其他代码段称为`剩余区`，如下图所示。

![](https://raw.githubusercontent.com/liferlisiqi/liferlisiqi.github.io/master/img/2018-12-09-os20.jpg)

解决临界区问题需要满足如下三个要求：
- `互斥`（mutual exclusion）：如果某进程在其临界区内，那么其他进程都不能在其临界区内执行。
- `前进`（progress）：如果没有进程在其临界区内执行且有进程需要进入临界区，那么只有那些不再剩余区内执行的进程可参加选择。
- `有限等待`（bounded waiting）：从一个进程做出进入临界区的请求，直到该请求允许为止，其他进程允许进入其临界区的次数有上限。

有两种方法用于处理操作系统内的临界区问题：`抢占内核`（preemptive kernel）与`非抢占内核`（nonpreemptive kernel）。抢占内核允许处于内核模式的进程被抢占，非抢占内核不允许处于内核模式的进程被抢占。

# 2 临界区的实现方法
临界区的实现方法有三种：禁用中断、软件方法和更高级的抽象方法。禁用硬件中断后，无法进行上下文切换，因此没有并发。由于进程无法被停止，可能导致其他进程处于饥饿状态。一种经典的基于软件的临界区实现是Peterson算法，在该算法中进程的结构如下图所示。Peterson算法需要在两个进程之间共享两个数据项：turn和flag[]，turn表示哪个进程**可以**进入临界区，数据flag表示哪个进程**想要**进入临界区。

![](https://raw.githubusercontent.com/liferlisiqi/liferlisiqi.github.io/master/img/2018-12-09-os21.jpg)

操作系统也提供更高级的编程抽象来简化进程同步，例如：锁、信号量，并通过硬件原语来构建。现代操作系统都提供一些特殊的原子操作指令，如TestAndSet(TS)指令和Swap指令。使用这两种原子操作指令实现互斥的做法如下面两幅图所示。

```c++
boolean TestAndSet(boolean *target){
    boolean rv = *target;
    *targe = TRUE;
    return rv;
}

do{
    while(TestAndSet(&lock))
        ; // do nothing
        // critical section
    lock = FALSE;
        // remainder section
}while(TRUE);

```

```c++
void Swap(boolean *a, boolean *b){
    boolean temp = *a;
    *a = *b;
    *b = temp;
}

do{
    key = TRUE;
    while(key == TRUE)
        Swap(&lock, &key);
        // cirtical section
    lock = FALSE;
        // remainder section
}while(TRUE);
```

上面的算法实现了互斥，但是没有解决有限等待要求，下面是一种使用指令TestAndSet实现的算法，该算法满足所有临界区的三个要求。算法共用数据结构如下：

```c++
boolean waiting[n];
boolean lock;
```

这些数据结构均初始化为false，只有当 waiting[i] == false 或者 lock == false 时，进程才进入临界区。


```c++
do{
    waiting[i] = TRUE
    key = TRUE
    while(waiting[i] && key)
        key = TestAndSet(&lock);
    waiting[i] = FALSE;
    
        // critical section
        
    j = (i + 1) % n;
    while((j != i) && !waiting[j])
        j = (j + 1) % n;
        
    if(j == i)
        lock = FALSE;
    else
        waiting[j] = FALSE;
        
        // remainder section  
        
}while(TRUE);
```

# 3 信号量


# 4 管程



## Reference
操作系统概念    
[操作系统-清华大学](http://os.cs.tsinghua.edu.cn/oscourse/OS2017spring)  
[Operation system: three easy piece](http://pages.cs.wisc.edu/~remzi/OSTEP/) 
